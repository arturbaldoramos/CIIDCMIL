services:
  postgres:
    image: postgres:alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret # Em produção real, use secrets!
      POSTGRES_DB: db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres']
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:alpine
    networks:
      - app-network

  app: # API NestJS
    build:
      context: .
      dockerfile: Dockerfile.api.prod # Usa o novo Dockerfile
    environment:
      - NODE_ENV=production
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - DATABASE_URL="postgresql://postgres:secret@localhost:5432/db?schema=public"
      - MAILER_USER="noreply.todoapp123@gmail.com"
      - MAILER_PASS="ylviubcjrdsbqjsd"
      - JWT_SECRET="e4acb7a1f0283e1c7c9a609a2c1b329372b4fa20f3be11134e8d18b654096af3"
      - JWT_REFRESH_SECRET="b4a1f0283e1c7c9a609a2c1b329372b4fa20f3be11134e8d18b654096af3e4ac"
      - CORS_ORIGIN="http://localhost:5173"
      # Adicione aqui suas outras variáveis de ambiente de produção (JWT_SECRET, etc.)
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - app-network
    ports:
      - "3000:3000"

  web: # Frontend React com Nginx
    build:
      context: .
      dockerfile: Dockerfile.web.prod # Usa o novo Dockerfile
    ports:
      - "80:80" # Expõe o Nginx na porta 80
    depends_on:
      - app
    networks:
      - app-network

volumes:
  postgres_data:

networks:
  app-network:
    driver: bridge